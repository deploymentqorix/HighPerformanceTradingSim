#pragma once
#include "order.h"
#include "trade.h"
#include "market_data.h"
#include <vector>
#include <map>
#include <list>
#include <unordered_map>
#include <functional>
#include <string>

/**
 * @class OrderBook
 * @brief Manages the buy (bid) and sell (ask) orders for a single instrument.
 *
 * Implements a price-time priority matching algorithm. Orders are sorted by price,
 * and then by time of arrival (FIFO). Uses std::map for price sorting and std::list
 * for O(1) order cancellation.
 */
class OrderBook {
public:
    /// @brief Adds a new order to the book, attempting to match it against existing orders.
    /// @return A vector of trades generated by this order.
    std::vector<Trade> addOrder(const Order& order);

    /// @brief Cancels an existing resting order.
    void cancelOrder(int orderId);

    /// @brief Gets a snapshot of the current aggregated order book depth.
    MarketDepth getMarketDepth() const;

    // Requirement: QCSIDM_SRS_030 (Order book persistence)
    void saveToFile(const std::string& filepath) const;
    void loadFromFile(const std::string& filepath);

private:
    using OrderList = std::list<Order*>;

    struct OrderPointers {
        Order* order_ptr;
        OrderList::iterator list_iterator;
    };

    std::map<double, OrderList, std::greater<double>> bids;
    std::map<double, OrderList> asks;
    std::unordered_map<int, Order> order_pool;
    std::unordered_map<int, OrderPointers> order_locations;
};